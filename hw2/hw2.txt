I tried a number of different implementations of this project before I found success.

My first attempt at the problem included a number of different functions, including functions for both the left and right hand sides, including auxilliary functions for the prefixes. This approach led to a world of debugging that led me to rethink the problem. I returned to the TA's slides to understand better and re-attempt the problem from the two function or_matcher and make_matcher method that was originally suggested in the hint.

One of the things I had a hard time figuring out was where to keep the derivation as it was being built by the two functions. At first I thought a global variable would work to accomplish this, but I then realized that such variables were not allowed. I then decided to pass the derivation as a parameter to each of the functions, allowing them, through mutual recursion, to build it using the @ operator to concatenate to the derivation when calling the match_one. My implementation uses two functions, matcher and match_one. 

matcher (the matcher) - takes a start symbol, rule list, atom function, derivation, acceptor function, and fragment. At first, this function obtains the rules apply to the first symbol and begins applying them by calling match_one which is passed individual rules right hand sides and an updated derivation which includes the current rule being processed. 

match_one (the acceptor) - accepts the same parameters matcher (sans the rules list and start symbol). It begins by checking each literal in the rule. If the literal is nonterminal, it recurses its right side one by one Eventually, it triggers its base case, which returns the acceptor function, derivation, and suffix back to the matcher.

I originally had the functions declared separately, which worked for very trivial test cases but when backtracking got involved I ran into issues. When backtracking to I spent a great amount of time attempting to debug this problem before seeing a question on piazza that asked about mutually-recursive functions. The TA's answer suggested the Ocaml "and" keyword - which I realized could be useful in this case. I did some reading on the "and" and "in" keywords and realized I would be able to nest each of the functions within parse_prefix, greatly simplifying my code and, using "and" allowing the mutual recursion to work correctly. 

After completing this task, the entirety of the given test cases in hw2sample.ml as well as my own test cases in hw2test.ml passed successfully following minor further changes.